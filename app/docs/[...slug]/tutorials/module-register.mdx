# Module registration

## Introduction

If you want your miner or validator to be recognized by the network, you need to register it as a module. Also, if you're about to register a miner,
make sure that you [served](/docs/mining/run-miner) it beforehand or no validator will be able to connect to it.

## Registering a module

### Registering Through CLI

```bash
comx module register <module_name> <module_key> [--ip <integer>] [--port <integer>] [--netuid <integer>] [--stake <float>] [--metadata <text>] [--new-subnet-name]
```

Note that there's a **burn** for registration, and this is dynamic. You'll be informed the amount when you try to register
and be prompted to accept it. The tokens that are burned on registration are permanently lost.

The arguments inside braces are optional. Please note that if want to register a miner, you should provide the public ip and port in which your
miner is running. **--stake** is how much stake you're going to put on your module initially, and it defaults to the minimum stake + the registration burn
of the subnet you're being registered. You can use **--new-subnet-name** if you want to register the module on a brand new subnet that you're creating now.

The call to the blockchain then gets processed as follows.

```py
 def register_module(
        self,
        key: Keypair,
        name: str,
        address: str | None = None,
        subnet: str = 'commune',
        min_stake: int | None = None,
        metadata: str | None = None,
    ) -> ExtrinsicReceipt:

        stake = self.get_min_stake() if min_stake is None else min_stake

        key_addr = key.ss58_address

        params = {
            "network": subnet,
            "address": address,
            "name": name,
            "stake": stake,
            "module_key": key_addr,
            "metadata": metadata,
        }

        response = self.compose_call("register", params=params, key=key)
        return response
```

If you are not satisfied with any parameter on your module, you can update it

```bash
comx module update <key-name> <module-name> <ip> <port> [--delegation-fee] [--netuid] [--metadata]
```

The call to the blockchain then gets processed as follows.

```py
def update_module(
        self,
        key: Keypair,
        name: str,
        address: str,
        metadata: str | None = None,
        delegation_fee: int = 20,
        netuid: int = 0,
    ) -> ExtrinsicReceipt:

        assert isinstance(delegation_fee, int)

        params = {
            "netuid": netuid,
            "name": name,
            "address": address,
            "delegation_fee": delegation_fee,
            "metadata": metadata,
        }

        response = self.compose_call("update_module", params=params, key=key)

        return response
```